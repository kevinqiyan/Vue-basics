# 正则

### 入门

```
^ 为匹配字符串的开始位置
[0-9]+ 匹配多个数字, [0-9] 匹配单个数字, + 匹配一个或多个
abc$ 匹配字母 abc 并以 abc 结尾, $为匹配输入字符串的结束位置
```



### 语法

```
runoob+b 可以匹配runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）

runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）

colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。
```

#### 普通字符串

```
[A-Z] 表示一个区间,匹配所有大写字母 [a-z]表示所有小写字母
[ABC] 匹配[...]所有的字符(包含ABC)
[^ABC]匹配除了[...]中的字符(除了ABC)
[\s\S]匹配所有. \s是匹配所有空白符,包括换行,\S非空白符,包括换行
\w 匹配字母,数字,下划线 等价于 [A-Za-z0-9_]
```

#### 特殊字符串

```
$ 匹配输入字符串的结尾位置,设置RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。
() 标记一个子表达式的开始和结束位置,子表达式可以获取供以后使用,匹配本身使用 \( 和 \)
* 匹配前面的子表达式零次或多次,匹配本身 \*
+ 匹配前面的子表达式一次或多次,匹配本身 \+
| 指明两项之间的一个选择,匹配本身 \|
```

#### 限定符

```
* 匹配前面的子表达式零次或多次,等价于{0,} 例如 zo* 能匹配'z'以及'zoo'
? 匹配前面的子表达式零次或一次,等价于{0,1}
{n} n是一个非负整数,匹配确定的n次.例如:'o{2}'不能匹配'Bob'中的 'o',但是可以匹配 'food'中的两个 'o'
{n,} 至少匹配 n 次
{n,m} m和n 均属于非负整数, 其中 n<=m 最少匹配n次且最多匹配m次,例如'o{1,3}'将匹配 'fooood'中的前三个o,'o{0,1}'等价于 'o?'-->等价于只匹配零次或一次
```

**备注**

1.  ***** 和 **+** 限定符都是贪婪的,会尽可能多的匹配文字,只有在他们后面添加 **?** 就可以实现非贪婪或最小匹配(从贪婪表达式转换为非贪婪表达式)

   ```
   <h1>正则匹配教程演示</h1>
   /<.*>/ -->匹配整个字符串
   
   非贪婪
   /<.*?>/ --> 匹配第一个 h1 标签 <h1>
   ```

#### 定位符

```
\b 匹配一个单词边界,即字与空格间的位置.
	如果它位于要匹配字符串的开始,则它在单词的开始处查找匹配项.
	如果它位于字符串的结尾,它在单词的结尾处查找匹配项
\B 非单词边界匹配
```

#### 选择

```
() 将所有选择项括起来,相邻的选择项之间用 | 分隔
() 表示捕获数组,()会把每个分组里的匹配的值保存起来,多个匹配值可以通过数组 n 来查看(n是一个数字,表示第n个捕获组的内容)
```

[![Bi7S9e.png](https://s1.ax1x.com/2020/10/22/Bi7S9e.png)](https://imgchr.com/i/Bi7S9e)

**?=  ?<=  ?!  ?<!  的使用区别**

```
?=
ps: abc1(?=abc2):查找abc2前面的abc1

?<=
ps: (?<=abc2)abc1:查找abc2后面的abc1

?!
ps:abc1(?!abc2):查找后面不是abc2的abc1

?<!
ps:(?<!abc2)abc1:查找前面不是abc2的abc1
```

[![BiXkHs.png](https://s1.ax1x.com/2020/10/22/BiXkHs.png)](https://imgchr.com/i/BiXkHs)

[![BiXGU1.png](https://s1.ax1x.com/2020/10/22/BiXGU1.png)](https://imgchr.com/i/BiXGU1)

[![BiXrVA.png](https://s1.ax1x.com/2020/10/22/BiXrVA.png)](https://imgchr.com/i/BiXrVA)

[![BiX228.png](https://s1.ax1x.com/2020/10/22/BiX228.png)](https://imgchr.com/i/BiX228)

#### 反向引用

特点:提供查找文本中两个相同的相邻单词的匹配项的能力

```
var str = "Is is the cost of of gasoline going up up";
var patt1 = /\b([a-z]+) \1\b/ig;
document.write(str.match(patt1)); // Is is,of of,up up

解析: [a-z]+ 匹配一个或多个字母, 
      \1->指定第一个子匹配项, 
      g->将该表达式应用到输入自渡川能够找到的尽可能多的匹配
      i->表达式的结尾处不区分大小写
```

**重点示例(解析)**

[![BF9VL8.png](https://s1.ax1x.com/2020/10/22/BF9VL8.png)](https://imgchr.com/i/BF9VL8)